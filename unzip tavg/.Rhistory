---
title: "Untitled"
## R Markdown
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
```{r setup, include=FALSE}
shiny::runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
# Load required libraries
library(terra)
library(leaflet)
library(raster)
library(sf)
library(htmlwidgets)
# Set working directory
setwd("C:/Users/chake/Downloads/unzip tavg/")
# Read all . tif files (your average temperature data)
r <- rast(list.files(pattern = "tif$", full.names = TRUE))
print(paste("Loaded", nlyr(r), "raster layers"))
# Calculate annual mean
annual_mean <- mean(r, na.rm = TRUE)
annual_raster <- raster(annual_mean)
# ============================================================================
# CREATE A SIMPLE GRID OF CELLS (no country download needed)
# ============================================================================
# Get the extent of your raster
ext_r <- ext(annual_mean)
# Create a grid - divide the world into cells
n_rows <- 18  # number of latitude bands
n_cols <- 36  # number of longitude bands
# Calculate cell size
cell_width <- (ext_r[2] - ext_r[1]) / n_cols
cell_height <- (ext_r[4] - ext_r[3]) / n_rows
# Create grid cells
grid_cells <- list()
cell_id <- 1
for(i in 1:n_rows) {
for(j in 1:n_cols) {
# Calculate cell boundaries
xmin <- ext_r[1] + (j-1) * cell_width
xmax <- xmin + cell_width
ymin <- ext_r[3] + (i-1) * cell_height
ymax <- ymin + cell_height
# Create polygon
coords <- matrix(c(
xmin, ymin,
xmax, ymin,
xmax, ymax,
xmin, ymax,
xmin, ymin
), ncol = 2, byrow = TRUE)
poly <- st_polygon(list(coords))
grid_cells[[cell_id]] <- poly
cell_id <- cell_id + 1
}
}
# Convert to sf object
grid_sf <- st_sf(
cell_id = 1:length(grid_cells),
geometry = st_sfc(grid_cells, crs = crs(annual_mean))
)
print(paste("Created", nrow(grid_sf), "grid cells"))
# ============================================================================
# CALCULATE AVERAGE TEMPERATURE FOR EACH CELL
# ============================================================================
grid_sf$temp_mean <- NA
grid_sf$temp_percent <- NA
grid_sf$lat_center <- NA
grid_sf$lon_center <- NA
# Calculate global maximum for percentage
global_max <- global(annual_mean, "max", na.rm = TRUE)$max
global_min <- global(annual_mean, "min", na.rm = TRUE)$min
print("Processing grid cells...  Please wait...")
for(i in 1:nrow(grid_sf)) {
cell_poly <- vect(grid_sf[i, ])
tryCatch({
# Crop and mask to cell
cropped <- crop(annual_mean, cell_poly)
masked <- mask(cropped, cell_poly)
# Calculate mean
cell_mean <- global(masked, "mean", na. rm = TRUE)$mean
# Load required libraries
library(terra)
library(leaflet)
library(raster)
library(sf)
library(htmlwidgets)
# Set working directory
setwd("C:/Users/chake/Downloads/unzip tavg/")
# Read all . tif files (your average temperature data)
r <- rast(list.files(pattern = "tif$", full.names = TRUE))
print(paste("Loaded", nlyr(r), "raster layers"))
# Calculate annual mean
annual_mean <- mean(r, na.rm = TRUE)
annual_raster <- raster(annual_mean)
# ============================================================================
# CREATE A SIMPLE GRID OF CELLS (no country download needed)
# ============================================================================
# Get the extent of your raster
ext_r <- ext(annual_mean)
# Create a grid - divide the world into cells
n_rows <- 18  # number of latitude bands
n_cols <- 36  # number of longitude bands
# Calculate cell size
cell_width <- (ext_r[2] - ext_r[1]) / n_cols
cell_height <- (ext_r[4] - ext_r[3]) / n_rows
# Create grid cells
grid_cells <- list()
cell_id <- 1
for(i in 1:n_rows) {
for(j in 1:n_cols) {
# Calculate cell boundaries
xmin <- ext_r[1] + (j-1) * cell_width
xmax <- xmin + cell_width
ymin <- ext_r[3] + (i-1) * cell_height
ymax <- ymin + cell_height
# Create polygon
coords <- matrix(c(
xmin, ymin,
xmax, ymin,
xmax, ymax,
xmin, ymax,
xmin, ymin
), ncol = 2, byrow = TRUE)
poly <- st_polygon(list(coords))
grid_cells[[cell_id]] <- poly
cell_id <- cell_id + 1
}
}
# Convert to sf object
grid_sf <- st_sf(
cell_id = 1:length(grid_cells),
geometry = st_sfc(grid_cells, crs = crs(annual_mean))
)
print(paste("Created", nrow(grid_sf), "grid cells"))
# ============================================================================
# CALCULATE AVERAGE TEMPERATURE FOR EACH CELL
# ============================================================================
grid_sf$temp_mean <- NA
grid_sf$temp_percent <- NA
grid_sf$lat_center <- NA
grid_sf$lon_center <- NA
# Calculate global maximum for percentage
global_max <- global(annual_mean, "max", na.rm = TRUE)$max
global_min <- global(annual_mean, "min", na.rm = TRUE)$min
print("Processing grid cells...  Please wait...")
for(i in 1:nrow(grid_sf)) {
cell_poly <- vect(grid_sf[i, ])
tryCatch({
# Crop and mask to cell
cropped <- crop(annual_mean, cell_poly)
masked <- mask(cropped, cell_poly)
# Calculate mean
cell_mean <- global(masked, "mean", na.rm = TRUE)$mean
grid_sf$temp_mean[i] <- round(cell_mean, 1)  # 1 decimal for ¬∞C
grid_sf$temp_percent[i] <- round((cell_mean / global_max) * 100, 2)
# Get center coordinates
centroid <- st_centroid(grid_sf[i, ])
coords <- st_coordinates(centroid)
grid_sf$lat_center[i] <- round(coords[2], 1)
grid_sf$lon_center[i] <- round(coords[1], 1)
}, error = function(e) {
grid_sf$temp_mean[i] <- NA
grid_sf$temp_percent[i] <- NA
})
# Progress indicator
if(i %% 100 == 0) {
print(paste("Processed", i, "of", nrow(grid_sf), "cells"))
}
}
print("‚úÖ Processing complete!")
# Remove cells with no data
grid_clean <- grid_sf[! is.na(grid_sf$temp_mean), ]
# ============================================================================
# CREATE COLOR PALETTES - Red theme for temperature
# ============================================================================
# Color palette for grid cells (red gradient)
pal_grid <- colorNumeric(
palette = colorRampPalette(c("#FFEBEE", "#FFCDD2", "#EF9A9A", "#E57373",
"#EF5350", "#F44336", "#E53935", "#D32F2F",
"#C62828"))(9),
domain = grid_clean$temp_mean,
na.color = "transparent"
)
# Color palette for raster
pal_raster <- colorNumeric(
palette = colorRampPalette(c("#FFEBEE", "#FFCDD2", "#EF9A9A", "#E57373",
"#EF5350", "#F44336", "#E53935", "#D32F2F",
"#C62828"))(9),
domain = values(annual_raster),
na. color = "transparent"
# Load required libraries
library(terra)
library(leaflet)
library(raster)
library(sf)
library(htmlwidgets)
# Set working directory
setwd("C:/Users/chake/Downloads/unzip tavg/")
# Read all . tif files (your average temperature data)
r <- rast(list.files(pattern = "tif$", full.names = TRUE))
print(paste("Loaded", nlyr(r), "raster layers"))
# Calculate annual mean
annual_mean <- mean(r, na.rm = TRUE)
annual_raster <- raster(annual_mean)
# ============================================================================
# CREATE A SIMPLE GRID OF CELLS (no country download needed)
# ============================================================================
# Get the extent of your raster
ext_r <- ext(annual_mean)
# Create a grid - divide the world into cells
n_rows <- 18  # number of latitude bands
n_cols <- 36  # number of longitude bands
# Calculate cell size
cell_width <- (ext_r[2] - ext_r[1]) / n_cols
cell_height <- (ext_r[4] - ext_r[3]) / n_rows
# Create grid cells
grid_cells <- list()
cell_id <- 1
for(i in 1:n_rows) {
for(j in 1:n_cols) {
# Calculate cell boundaries
xmin <- ext_r[1] + (j-1) * cell_width
xmax <- xmin + cell_width
ymin <- ext_r[3] + (i-1) * cell_height
ymax <- ymin + cell_height
# Create polygon
coords <- matrix(c(
xmin, ymin,
xmax, ymin,
xmax, ymax,
xmin, ymax,
xmin, ymin
), ncol = 2, byrow = TRUE)
poly <- st_polygon(list(coords))
grid_cells[[cell_id]] <- poly
cell_id <- cell_id + 1
}
}
# Convert to sf object
grid_sf <- st_sf(
cell_id = 1:length(grid_cells),
geometry = st_sfc(grid_cells, crs = crs(annual_mean))
)
print(paste("Created", nrow(grid_sf), "grid cells"))
# ============================================================================
# CALCULATE AVERAGE TEMPERATURE FOR EACH CELL
# ============================================================================
grid_sf$temp_mean <- NA
grid_sf$temp_percent <- NA
grid_sf$lat_center <- NA
grid_sf$lon_center <- NA
# Calculate global maximum for percentage
global_max <- global(annual_mean, "max", na.rm = TRUE)$max
global_min <- global(annual_mean, "min", na.rm = TRUE)$min
print("Processing grid cells...  Please wait...")
for(i in 1:nrow(grid_sf)) {
cell_poly <- vect(grid_sf[i, ])
tryCatch({
# Crop and mask to cell
cropped <- crop(annual_mean, cell_poly)
masked <- mask(cropped, cell_poly)
# Calculate mean
cell_mean <- global(masked, "mean", na.rm = TRUE)$mean
grid_sf$temp_mean[i] <- round(cell_mean, 1)  # 1 decimal for ¬∞C
grid_sf$temp_percent[i] <- round((cell_mean / global_max) * 100, 2)
# Get center coordinates
centroid <- st_centroid(grid_sf[i, ])
coords <- st_coordinates(centroid)
grid_sf$lat_center[i] <- round(coords[2], 1)
grid_sf$lon_center[i] <- round(coords[1], 1)
}, error = function(e) {
grid_sf$temp_mean[i] <- NA
grid_sf$temp_percent[i] <- NA
})
# Progress indicator
if(i %% 100 == 0) {
print(paste("Processed", i, "of", nrow(grid_sf), "cells"))
}
}
print("‚úÖ Processing complete!")
# Remove cells with no data
grid_clean <- grid_sf[! is.na(grid_sf$temp_mean), ]
# ============================================================================
# CREATE COLOR PALETTES - Red theme for temperature
# ============================================================================
# Color palette for grid cells (red gradient)
pal_grid <- colorNumeric(
palette = colorRampPalette(c("#FFEBEE", "#FFCDD2", "#EF9A9A", "#E57373",
"#EF5350", "#F44336", "#E53935", "#D32F2F",
"#C62828"))(9),
domain = grid_clean$temp_mean,
na.color = "transparent"
)
# Color palette for raster
pal_raster <- colorNumeric(
palette = colorRampPalette(c("#FFEBEE", "#FFCDD2", "#EF9A9A", "#E57373",
"#EF5350", "#F44336", "#E53935", "#D32F2F",
"#C62828"))(9),
domain = values(annual_raster),
na.color = "transparent"
)
# ============================================================================
# CREATE INTERACTIVE MAP - HOVER TO SEE VALUES
# ============================================================================
interactive_map <- leaflet(grid_clean) %>%
# Add base maps
addProviderTiles(providers$CartoDB.Positron, group = "Light Map") %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
addProviderTiles(providers$OpenStreetMap, group = "Street Map") %>%
# Add the average temperature raster
addRasterImage(annual_raster,
colors = pal_raster,
opacity = 0.7,
maxBytes = 8 * 1024 * 1024,
group = "Average Temperature") %>%
# Add grid cells with HOVER labels
addPolygons(
fillColor = ~pal_grid(temp_mean),
fillOpacity = 0.6,
color = "#FFFFFF",
weight = 1,
opacity = 0.8,
# ‚≠ê HOVER LABEL - Shows location and temperature
label = ~lapply(paste0(
"<b>üìç Location:</b> ", lat_center, "¬∞N, ", lon_center, "¬∞E<br/>",
"<b>üå°Ô∏è Average Temperature:</b> ", temp_mean, " ¬∞C<br/>",
"<b>üìä Percentage:</b> ", temp_percent, "% of maximum"
), htmltools::HTML),
labelOptions = labelOptions(
style = list(
"font-weight" = "bold",
"font-size" = "14px",
"padding" = "10px",
"background-color" = "rgba(255, 255, 255, 0.95)",
"border" = "3px solid #F44336",
"border-radius" = "8px",
"box-shadow" = "0 0 15px rgba(244, 67, 54, 0.6)"
),
textsize = "14px",
direction = "auto",
sticky = TRUE,
opacity = 1
),
# Highlight effect when hovering
highlightOptions = highlightOptions(
weight = 3,
color = "#D32F2F",
fillOpacity = 0.9,
bringToFront = TRUE
),
group = "Grid Cells"
) %>%
# Add legend
addLegend(
pal = pal_grid,
values = ~temp_mean,
title = "Average<br/>Temperature (¬∞C)",
position = "bottomright",
opacity = 1
) %>%
# Layer control
addLayersControl(
baseGroups = c("Light Map", "Satellite", "Street Map"),
overlayGroups = c("Average Temperature", "Grid Cells"),
options = layersControlOptions(collapsed = FALSE)
) %>%
# Add scale bar
addScaleBar(position = "bottomleft") %>%
# Set initial view
setView(lng = 10, lat = 20, zoom = 2)
# Display the map
interactive_map
# Save the interactive map as HTML
saveWidget(interactive_map,
file = "average_temperature_interactive_grid.html",
selfcontained = TRUE)
# ============================================================================
# PRINT SUMMARY
# ============================================================================
cat("\n")
cat("========================================\n")
cat("‚úÖ INTERACTIVE MAP CREATED SUCCESSFULLY!\n")
cat("========================================\n\n")
cat("üñ±Ô∏è  HOW TO USE:\n")
cat("   ‚Ä¢ Hover over any cell to see:\n")
cat("     - Location coordinates\n")
cat("     - Average temperature value (¬∞C)\n")
cat("     - Percentage of maximum\n\n")
cat("   ‚Ä¢ Use mouse wheel to ZOOM in/out\n")
cat("   ‚Ä¢ Click and drag to PAN\n")
cat("   ‚Ä¢ Switch between map styles in top-right\n\n")
cat("üìÅ FILE CREATED:\n")
cat("   ‚Ä¢ average_temperature_interactive_grid. html\n")
cat("     (Open this in any web browser! )\n\n")
# ============================================================================
# CREATE DATA TABLE
# ============================================================================
grid_summary <- data.frame(
Cell_ID = grid_clean$cell_id,
Latitude = grid_clean$lat_center,
Longitude = grid_clean$lon_center,
Avg_Temperature = grid_clean$temp_mean,
Percent_of_Max = grid_clean$temp_percent
)
# Sort by temperature (highest first)
grid_summary <- grid_summary[order(-grid_summary$Avg_Temperature), ]
# Print top 20
cat("========================================\n")
cat("TOP 20 HIGHEST AVERAGE TEMPERATURE AREAS:\n")
cat("========================================\n")
print(head(grid_summary, 20), row.names = FALSE)
# Save to CSV
write.csv(grid_summary,
"average_temperature_grid_summary.csv",
row.names = FALSE)
cat("\nüìä Full data saved to:\n")
cat("   ‚Ä¢ average_temperature_grid_summary.csv\n")
cat("========================================\n")
# ============================================================================
# BONUS: Create simple static plots
# ============================================================================
# Plot the grid with average temperature
plot(st_geometry(grid_clean),
col = pal_grid(grid_clean$temp_mean),
border = "white",
lwd = 0. 5,
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
runApp('C:/Users/chake/OneDrive/Images/R programs/myapp')
